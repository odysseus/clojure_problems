(ns cljeuler.ninety-nine)

;; Problem 1
(defn my-last
  "Alternate Form using recur"
  [ls]
  (if (empty? (rest ls))
    (first ls)
    (recur (rest ls))))

;; Problem 1
(defn alt-last
  "Find the last element of a list"
  [ls]
  (if (empty? (rest ls))
    (first ls)
    (alt-last (rest ls))))

;; Problem 2
(defn second-to-last
  "Alternate form using recur"
  [ls]
  (if (empty? (next (next ls)))
    (first ls)
    (recur (rest ls))))

;; Problem 2
(defn alt-second-to-last
  "Return the second to last element of a list"
  [ls]
  (if (= (count ls) 2)
    (first ls)
    (alt-second-to-last (rest ls))))

;; Problem 3
(defn kth
  "Find the Kth element of a list, the first element is 1"
  [ls k]
  (loop [l (seq ls) c 1]
    (if (= k c)
      (first l)
      (recur (rest l) (inc c)))))

;; Problem 4
(defn my-count
  "Find the number of elements in a list"
  [ls]
    (loop [l (seq ls) c 0]
      (if (empty? l)
        c
        (recur (rest l) (inc c)))))

;; Problem 4
(defn alt-my-count
  "Alternative answer to 4 using plain recursion"
  [ls]
    (if (empty? ls)
      0
      (+ 1 (alt-my-count (rest ls)))))

;; Problem 5
(defn my-reverse
  "Reverse a list"
  [ls]
  (let [l (seq ls)]
    (loop [[h & t :as all] l fin '()]
      (if all
        (recur t (cons h fin))
        fin))))

;; Problem 5
(defn alt-reverse
  "Alternative form for five"
  [ls]
  (let [l (seq ls)]
    (defn iter-five [l fin]
      (if (empty? l)
        fin
        (iter-five (rest l) (cons (first l) fin))))
    (iter-five l '())))

;; Problem 5
(defn alt-alt-reverse
  "Yet another way to reverse a sequence"
  [xs]
  (if (empty? xs)
    '()
    (reduce conj '() xs)))

;; Problem 6
(defn palindrome?
  "Find out whether a list is a palindrome"
  [ls]
  (= ls (my-reverse ls)))

;; Problem 7
(defn my-flatten
  "Flatten a list"
  [l]
  (if (empty? l)
    nil
    (if (not (seq? (first l)))
      (concat (cons (first l) nil) (my-flatten (rest l)))
      (concat (my-flatten (first l)) (my-flatten (rest l))))))

;; Problem 8
(defn eliminate-consecutive-dupes
  "Eliminate consecutive duplicates of list elements"
  [ls]
  (let [[head & tail :as l] (seq ls)]
    (if (empty? l)
      nil
      (if (not= head (first tail))
        (concat (cons head nil) (eliminate-consecutive-dupes tail))
        (concat '() (eliminate-consecutive-dupes tail))))))

;; Problem 9
(defn alt-pack
  "Group consecutive elements in a list"
  [ls]
  (reverse (reduce
             #(if (= (ffirst %1) %2)
                (cons (cons %2 (first %1)) (rest %1))
                (cons (list %2) %1))
             '()
             ls)))

;; Problem 9
(defn pack
  "Alternate answer for nine using a higher order function"
  [ls]
  (partition-by #(identity %) ls))

;; Problem 9
(defn tail-pack
  [xs]
  "Another way of solving nine with tail-end recursion"
  (loop [[head & tail :as all] xs
         fin '()
         tmp '()]
    (if (empty? all)
      (reverse (cons tmp fin))
      (if (or (= head (first tmp)) (empty? tmp))
        (recur tail fin (cons head tmp))
        (recur all (cons tmp fin) '())))))

;; Problem 10
(defn length-encoding
  "Run a length encoding of a list using the result from problem 9"
  [ls]
  (map #(list (first %) (count %)) (pack ls)))

;; Problem 11
(defn length-encode
  "Modify the answer from ten so that elements with no repetition are
  copied directly into the returned list without the (E N) encoding"
  [ls]
  (map #(if (= (count %) 1) (first %) (list (first %) (count %))) (pack ls)))

;; Problem 12
(defn decode-lencode
  "Decode the list generated by problem 11"
  [ls]
  (flatten (map #(if (seq? %) (repeat (last %) (first %)) %) ls)))

;; Problem 14
(defn dupe-each
  "Duplicate the elements of a list"
  [ls]
  (mapcat (partial repeat 2) ls))

;; Problem 15
(defn dupe-times
  "Duplicate the elements of a list a given number of times"
  [ls n]
  (mapcat (partial repeat n) ls))

;; Problem 16
(defn drop-every
  "Drop every nth element from a list"
  [ls n]
  (flatten (map #(if (= (count %) n) (butlast %) %) (partition-all n ls))))

;; Problem 17
(defn split
  "Split a list into two parts given the length of the first"
  [ls n]
  (cons (take n ls) (list (drop n ls))))

;; Problem 18
(defn slice
  "Extract a slice from a list"
  [ls a b]
  (take (- b a) (drop a ls)))

;; Problem 19
(defn rotate
  "Rotate a list N places to the left"
  [ls n]
  (concat (drop n ls) (take n ls)))

;; Problem 20
(defn remove-at
  "Remove the kth element from a list"
  [ls k]
  (concat (take k ls) (drop (inc k) ls)))

;; Problem 21
(defn insert-at
  "Insert an element at a given position in a list"
  [ls el k]
  (concat (take k ls) (cons el (drop k ls))))

;; Used by my-range
(defn range-iter
  "Used internally by my-range, can't be nested for variadic reasons"
  [a b step]
  (loop [c a ls '()]
    (if (> c b)
      (reverse ls)
      (recur (+ c step) (cons c ls)))))

;; Problem 22
(defn my-range
  "Create a list containing all integers within a given range"
  ([a] (range-iter 0 a 1))
  ([a b] (range-iter a b 1))
  ([a b c] (range-iter a b c)))

;; Problem 23
(defn random-select
  "Extract a given number of randomly selected elements from a list"
  [ls n]
  (defn rele [lz] (nth ls (int (* (rand 1) (count ls)))))
    (loop [c n fin '()]
      (if (= c 0)
        fin
        (recur (dec c) (cons (rele ls) fin)))))

;; Problem 24
(defn lottery
  "Draw N different random numbers from the set 1..M"
  [a b n]
  (defn randn [r] (int (* (rand 1) r)))
  (defn rmv [ls k] (concat (take k ls) (drop (inc k) ls)))
  (loop [c n
         ls (range a b)
         fin '()]
    (if (= c 0)
      fin
      (let [rn (randn (count ls))]
        (recur (dec c) (rmv ls rn) (cons (nth ls rn) fin))))))

;; Problem 25
(defn random-permutation
  "Generate a random permutation of the elements of the list"
  [ls]
  (defn randn [r] (int (* (rand 1) r)))
  (defn rmv [ls k] (concat (take k ls) (drop (inc k) ls)))
  (loop [tls ls
         fin '()]
    (if (empty? tls)
      fin
      (let [rn (randn (count tls))]
        (recur (rmv tls rn) (cons (nth tls rn) fin))))))

;; Problem 26
(defn combinations
  "Find all combinations of K distinct items from a set of N elements."
  [sq k]
  (if (zero? k)
    '(())
    (if (empty? sq)
      nil
      (let
        [[head & tail] sq
         with-head (combinations tail (dec k))
         without-head (combinations tail k)]
        (concat (map #(conj % head) with-head) without-head)))))

;; Problem 27
;; Disjoint subsets

;; Problem 28
(defn sort-by-sublist-length
  "Sort a list of lists by the length of its sublists"
  [ls]
  (sort-by count ls))

;; Used by factor checking functions
(defn int-root
  "Finds the square root of a number rounded to the nearest integer
  value and +1, useful for efficiently finding factors of numbers, where
  we only need the approximate root"
  [x]
  (+ (int (Math/sqrt x)) 1))

;; Used by factor checking functions
(defn diveven?
  "Does y evenly divide x"
  [x y]
  (= (mod x y) 0))

;; Problem 31
(defn prime?
  "Tests the primality of a number, with 100% accuracy.
  Using filter and anonymous functions rather than list comprehensions"
  [n]
  (defn threeven? [n] (= (mod n 3) 0))
  (if (or (= n 2) (= n 3) (= n 5) (= n 7))
    true
    (if (or (even? n) (threeven? n) (= n 1))
      false
      (empty? (filter #(= (mod n %) 0) (range 3 (int-root n) 2))))))

;; Problem 32
(defn gcd
 "Find the GCD of two numbers using Euclid's algorithm"
  [a b]
  (if (= b 0) a (gcd b (mod a b))))

;; Problem 33
(defn coprime?
  "Determine if two numbers are coprime"
  [a b]
  (= (gcd a b) 1))

;; Problem 34
(defn totient-phi
  "Find the number of integers less than M that are coprime to M"
  [m]
  (count (filter #(coprime? % m) (range 1 m))))

;; Problem 35
(defn prime-factors
  "Returns a list of prime factors of n"
  [n]
  (loop [current n
         counter 2
         facts '()]
    (if (> counter current)
      (reverse facts)
      (if (diveven? current counter)
        (recur (/ current counter) counter (cons counter facts))
        (recur current (inc counter) facts)))))

;; Problem 37
(defn prime-factors-mult
  "Calculates a list of prime factors and the number of times they occur"
  [n]
  (length-encoding (prime-factors n)))

;; Problem 38 involves comparing the solutions to 35 and 37

;; Problem 39
(defn improved-phi
  "Calculates Euler's improved totient function using prime factors"
  [n]
  (reduce *
          (map #(* (- (first %) 1) (int (Math/pow (first %) (- (last %) 1))))
               (prime-factors-mult n))))

;; Problem 39
(defn primes-in-range
  "Find all primes within the range a to b"
  [a b]
  (filter prime? (range a (inc b))))

;; Problem 40
(defn goldbach
  "Write a function that takes an even number and returns two prime numbers
  which sum to it."
  [n]
  (if (not (even? n))
    nil
    (loop [[ahead & atail :as aprimes] (primes-in-range 1 n)
           [bhead & btail :as bprimes] (primes-in-range 1 n)]
      (if (empty? bprimes)
          (recur atail atail)
        (if (= (+ ahead bhead) n)
          (list ahead bhead)
          (recur aprimes btail))))))


